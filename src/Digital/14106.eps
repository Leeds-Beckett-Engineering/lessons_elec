%!PS-Adobe-3.0 EPSF-3.0
%%Title: /home/dennis/Digital/14106.eps
%%Creator: Xcircuit v3.1
%%CreationDate: Mon Jun 28 17:16:48 2004
%%Pages: 1
%%BoundingBox: 68 68 392 373
%%DocumentNeededResources: font Helvetica font Courier font Courier-Bold 
%%EndComments
%%BeginProlog
%
%  PostScript prolog for output from xcircuit
%  Version: 2.4
%
%  Electrical circuit (and otherwise general) drawing program
%
%  Written by Tim Edwards 8/5/93--1/15/03  (tim@bach.ece.jhu.edu)
%  The Johns Hopkins University
%
%%BeginResource: procset XCIRCproc 2.4 2
% supporting definitions --- these are the primary xcircuit types.

/XCIRCsave save def
/topmat matrix currentmatrix def

/fontslant { /slant exch def [1 0 slant 1 0 0] 
    exch findfont exch makefont dup length dict /ndict exch def
    { 1 index /FID ne { ndict 3 1 roll put } { pop pop } ifelse } forall
    ndict definefont pop} def
/ul { dup type /stringtype eq showflag 1 eq and { gsave 
   currentpoint topmat setmatrix 0 0 moveto 2 index stringwidth pop (_)
   false charpath flattenpath pathbbox grestore exch pop 1 index
   sub setlinewidth exch pop currentpoint 3 -1 roll add moveto 0
   rlineto stroke moveto } if } def
/ol { dup type /stringtype eq showflag 1 eq and { gsave gsave
   currentpoint topmat setmatrix 2 index stringwidth pop 3 index
   true charpath flattenpath pathbbox grestore exch pop
   exch pop topmat setmatrix (_) true charpath pathbbox grestore
   exch pop 1 index sub setlinewidth exch pop currentpoint
   exch 4 1 roll exch sub add moveto pop 0 rlineto stroke
   moveto } if } def
/stW { gsave currentpoint newpath moveto true charpath flattenpath
	pathbbox pop exch pop sub grestore } def
/Ts {mark Tabs aload pop counttomark 1 add array astore /Tabs exch def Tabs
	0 currentpoint pop put} def
/Tbn {mark Tabs aload pop counttomark dup 2 add 1 roll cleartomark 1 sub} def
/Tb { 0 1 Tbn {Tabs exch get dup currentpoint pop lt
	{currentpoint exch pop moveto exit} {pop} ifelse } for } def
/Tf { Tbn -1 0 {Tabs exch get dup currentpoint pop gt
	{currentpoint exch pop moveto exit} {pop} ifelse } for } def
/qS { (aa) stW (a a) stW sub 4 div 0 Kn } def
/hS { qS qS } def
/pspc 0 def
/cf0 { scalefont setfont } bind def
/Kn { dup kY add /kY exch def rmoveto } bind def
/ss { /fscale fscale 0.67 mul def currentfont 0.67 cf0 0 fscale0 fscale mul
	0.33 mul neg Kn} def
/Ss { /fscale fscale 0.67 mul def currentfont 0.67 cf0 0 fscale0 fscale mul
	0.67 mul Kn } def
/ns { 0 kY neg Kn /kY 0 def /fscale 1.0 def xfont0 1.0 cf0 } def
/CR { ns 0 /Bline Bline fscale0 neg add def Bline moveto } def
/cf { dup type /realtype ne {1.0} if exch findfont exch kY 0 eq
	{ 40 mul dup /fscale0 exch def cf0 /xfont0 currentfont def}
	{fscale0 mul fscale mul cf0} ifelse } def
/ctmk { counttomark dup 2 add -1 roll pop } bind def
/label { gsave translate 0 0 moveto dup scale neg /rotval exch def
	/just exch def just 16 and 0 gt {gsave rotval rotate 0 1 dtransform
	gsave pagemat setmatrix idtransform exch grestore 1 0 dtransform
	gsave pagemat setmatrix idtransform exch grestore dup abs 1e-9 lt
	{pop mul 0 gt} {3 1 roll pop pop 0 lt} ifelse grestore {-1 /rotval
	rotval neg def /just just dup 3 and 1 ne {3 xor} if def} {1} ifelse
	exch -1e-9 lt {-1 /rotval rotval neg def /just just dup 12 and
	4 ne {12 xor} if def} {1} ifelse scale } if /showflag 0 def
	/fspc pspc def /Bline 0 def /Tabs 0 array def /fscale 1.0 def
	/kY 0 def gsave dup 1 add copy 0 exch 1 0 dtransform exch atan rotate
	{exch dup type /stringtype eq {true charpath flattenpath} {exec}
	ifelse } repeat pop pathbbox grestore 3 -1 roll pop 3 1 roll just
	1 and 0 gt {just 2 and 0 gt {exch pop neg fspc sub} {exch sub 0.5
	mul neg} ifelse} {pop neg fspc add} ifelse exch Bline exch just 4
	and 0 gt {just 8 and 0 gt {exch pop neg fspc sub} {add 0.5 mul neg}
	ifelse} {pop neg fspc add} ifelse rotval rotate Kn currentpoint
	translate /showflag 1 def /Bline 0 def /Tabs 0 array def /fscale
	1.0 def /kY 0 def {dup type /stringtype eq {show}{exec} ifelse}
	repeat grestore } def
/pinlabel { 4 index 32 and 0 ne hlevel 0 eq or { /pspc 10 def label
	/pspc 0 def } { pop pop pop pop pop {pop} repeat } ifelse } def
/pinglobal { pinlabel } def
/infolabel { pinlabel } def

/scb { setrgbcolor } bind def  /sce { defColor aload pop scb } bind def
/cRedef {/defColor currentcolor 3 array astore def} def
/begingate { /hlevel hlevel 1 add def /defColor currentcolor sce 3 array
	astore def gsave sce translate 0 0 moveto neg rotate dup abs scale
	} bind def
/makeparm  {3 string cvs dup length 1 add string /tstr exch def tstr exch
	1 exch putinterval tstr 0 (v) putinterval tstr cvn} bind def
/beginparm { -1 1 {makeparm exch def} for
	dup type /arraytype eq { aload length -1 1 {makeparm exch def}
	for } if begingate } bind def
/endgate { /hlevel hlevel 1 sub def grestore defColor aload pop cRedef
	scb} bind def

/hlevel 0 def
/tmpa [1 0 0 1 0 0] def
/gar {8 8 true tmpa {<c0 c0 00 00 0c 0c 00 00>} imagemask} bind
{8 8 true tmpa {<30 70 60 02 03 07 06 20>} imagemask} bind
{8 8 true tmpa {<0c 1e 1e 0c c0 e1 e1 c0>} imagemask} bind
{8 8 true tmpa {<0f 0f 0f 0f f0 f0 f0 f0>} imagemask} bind
{8 8 true tmpa {<3f f3 e1 e1 f3 3f 1e 1e>} imagemask} bind
{8 8 true tmpa {<df cf 8f 9f fd fc f8 f9>} imagemask} bind
{8 8 true tmpa {<ff 3f 3f ff ff f3 f3 ff>} imagemask} bind 7 array astore def
/ppaint { gsave clip tmpa dup setmatrix pathbbox neg exch neg 4 2 roll
  neg 4 -1 roll 2 copy gt {exch} if 8 div ceiling 8 mul 4 2 roll neg 2 copy
  gt {exch} if 8 div ceiling 8 mul 3 -1 roll -8 5 -1 roll
  { 3 index exch 5 exch put dup -8 3 index { 3 index
  exch 4 exch put 3 index exec } for } for pop pop pop pop grestore } bind def
/setstyles {
  currentlinewidth mul setlinewidth /style exch def
  style 1 and 0 gt not {closepath} if
  style 2 and 0 gt {currentlinewidth 4 mul dup 2 array astore 0 setdash} if
  style 4 and 0 gt {0.5 currentlinewidth 4 mul 2 array astore 0 setdash} if
  gsave style 16 and 0 gt { style 224 and -5 bitshift style 256 and 0 gt {
  7 exch sub 8 div dup 1 exch sub currentrgbcolor 3 array astore
  {3 copy mul add 4 1 roll pop} forall pop pop setrgbcolor eofill}
  {dup 7 lt {gar exch get ppaint} {pop eofill} ifelse} ifelse}
  {style 256 and 0 gt {1 setgray eofill} if} ifelse grestore style 8 and 0 gt 
  style 512 eq or {newpath} {stroke} ifelse grestore} def     

/polygon { gsave /num exch def moveto num 1 sub {lineto} repeat setstyles } def
/xcarc   { gsave newpath arc setstyles } def
/elb { matrix currentmatrix 7 -1 roll 7 -1 roll translate 5 1 roll 4 -1 roll
	3 index div 1 scale } def
/ele { 0 4 1 roll 0 4 1 roll } bind def
/ellipse { gsave elb newpath ele arc setmatrix setstyles } def
/pellip  { elb ele arc setmatrix } def
/nellip  { elb ele arcn setmatrix } def
/spline  { gsave moveto curveto setstyles } def
/polyc   { {lineto} repeat } bind def
/beginpath { gsave moveto } bind def
/endpath { setstyles } bind def
/bop	 { 1 setlinecap 0 setlinejoin 6 setmiterlimit 0 0 0 scb cRedef } def
/psinsertion {/PSobj save def /showpage {} def bop rotate translate dup scale} def
/end_insert {PSobj restore} def
/setpagemat {/pagemat matrix currentmatrix def} def
/inchscale  {setpagemat 0.375 mul dup scale} def
/cmscale    {setpagemat 0.35433071 mul dup scale} def

%%EndResource
%%EndProlog

% XCircuit output starts here.

/arrowg {
begingate
0.619 0.603 0.619 scb
1 1.00 0 -8 -4 8 2 polygon
1 1.00 0 -8 4 8 2 polygon
endgate
} def

%%Page: 1 1
%%PageOrientation: Portrait
/pgsave save def bop
% 166 160 offsets
% 27.08 1.70 gridspace
1.0831 inchscale
5.2000 setlinewidth

( 0) {CR} ( 1) {CR} (01) {CR} (00) {/Courier cf} 8 16 0 1.00 385 404 label
( 0) {CR} ( 1) {CR} ( 1) {CR} ( 0) {/Courier cf} 8 16 0 1.00 273 404 label
( 1) {CR} ( 0) {/Courier cf} 4 16 0 1.00 225 484 label
( 1) {CR} ( 0) {/Courier cf} 4 16 0 1.00 177 484 label
0.619 0.603 0.619 scb
1 1.00 241 476 277 476 2 polygon
1 1.00 293 476 329 476 2 polygon
1 1.00 397 476 433 476 2 polygon
sce
(10) {CR} (11) {CR} (01) {CR} (00) {/Courier cf} 8 16 0 1.00 465 404 label
0.619 0.603 0.619 scb
1 1.00 469 476 505 476 2 polygon
sce
(10) {CR} (11) {CR} (01) {CR} (00) {/Courier cf} 8 16 0 1.00 529 404 label
0.619 0.603 0.619 scb
1 1.00 329 480 28 -90.00 90.00 xcarc
1 1.00 333 477 44 57 270.00 445.24 ellipse
1 1.00 329 452 341 460 2 polygon
1 1.00 329 451 345 451 2 polygon
sce
(00) {CR} (01) {CR} (11) {CR} (10) {CR} (10) {CR} (11) {CR} (01) {CR} (00) 
{/Courier cf} 16 16 0 1.00 609 244 label
( 00) {CR} ( 01) {CR} ( 11) {CR} ( 10) {CR} (010) {CR} (011) {CR} (001) {CR} 
(000) {/Courier cf} 16 16 0 1.00 757 240 label
(100) {CR} (101) {CR} (111) {CR} (110) {CR} (010) {CR} (011) {CR} (001) {CR} 
(000) {/Courier cf} 16 16 0 1.00 885 240 label
0.619 0.603 0.619 scb
1 1.00 673 400 28 -90.00 90.00 xcarc
1 1.00 666 369 678 377 2 polygon
1 1.00 667 369 683 369 2 polygon
1 1.00 665 392 44 57 270.00 445.24 ellipse
1 1.00 617 388 103 104 295.46 427.17 ellipse
1 1.00 574 396 169 168 303.33 417.07 ellipse
1 1.00 621 396 657 396 2 polygon
1 1.00 789 392 825 392 2 polygon
sce
(How to generate Gray code.) {/Courier-Bold cf} 2 16 0 1.00 197 884 label
(1. Write 0,1 in a column.) {/Helvetica 0.500 cf} {/Helvetica cf} 3 16 0 1.00 
191 842 label
(2. Draw a mirror under the column.) {/Helvetica 0.500 cf} {/Helvetica cf} 3 31 
0 1.00 557 824 label
(3. Reflect the numbers about the mirror.) {/Helvetica 0.500 cf} 
{/Helvetica cf} 3 16 0 1.00 290 782 label
(4. Distinguish the numbers above the mirror with leading zeros.) 
{/Helvetica 0.500 cf} {/Helvetica cf} 3 16 0 1.00 381 746 label
(leading ones.) {/Helvetica 0.500 cf} (   ) {CR} 
(5. Distinguish those below the mirror with) {/Helvetica 0.500 cf} 
{/Helvetica cf} 7 16 0 1.00 468 668 label
(6. Finished 2-bit Gray code.) {/Helvetica 0.500 cf} {/Helvetica cf} 3 16 0 
1.00 538 622 label
0.619 0.603 0.619 scb
1 1.00 197 804 197 572 2 polygon
1 1.00 249 788 249 568 2 polygon
1 1.00 297 756 297 564 2 polygon
1 1.00 393 716 393 564 2 polygon
1 1.00 473 676 473 564 2 polygon
1 1.00 541 592 541 560 2 polygon
1 1.00 197 561 193 577 2 polygon
1 1.00 197 561 201 577 2 polygon
1 1.00 249 560 245 576 2 polygon
1 1.00 249 560 253 576 2 polygon
1 1.00 297 560 293 576 2 polygon
1 1.00 297 560 301 576 2 polygon
1 1.00 393 564 389 580 2 polygon
1 1.00 393 564 397 580 2 polygon
1 1.00 473 560 469 576 2 polygon
1 1.00 473 560 477 576 2 polygon
1 1.00 541 556 537 572 2 polygon
1 1.00 541 556 545 572 2 polygon
sce
(   mirror.) {CR} (   2-bit codes,reflect about ) {CR} 
(   mirror under column of four ) {CR} (7. Need 3-bit Gray code? Draw ) 
{/Helvetica cf} 8 31 0 0.50 497 372 label
(8. Distinguish upper 4-numbers with leading zeros.) {/Helvetica cf} 2 16 0 
0.50 209 216 label
(. Distinguish lower 4-numbers with leading ones.) {/Helvetica cf} (9) 
{/Courier cf} 4 16 0 0.50 209 180 label
0.619 0.603 0.619 scb
1 1.00 496 385 591 393 2 polygon
1 1.00 793 188 869 232 2 polygon
1 1.00 598 394 585 389 2 polygon
1 1.00 598 394 585 394 2 polygon
1 1.00 595 394 583 397 2 polygon
1 1.00 681 212 745 224 769 380 673 212 spline
1 1.00 677 372 673 372 2 polygon
sce
1.00 195 770 381 arrowg
1.00 75 337 420 arrowg
1.00 75 669 336 arrowg
1.00 60 661 293 arrowg
1.00 55 671 259 arrowg
1.00 240 870 233 arrowg
0.619 0.603 0.619 scb
1 1.00 792 189 668 189 2 polygon
pgsave restore showpage

%%Trailer
XCIRCsave restore
%%EOF

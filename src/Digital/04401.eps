%!PS-Adobe-3.0 EPSF-3.0
%%Title: shift/04401.eps
%%Creator: Xcircuit v3.1
%%CreationDate: Fri Jan 28 16:50:29 2005
%%Pages: 1
%%BoundingBox: 68 68 292 165
%%DocumentNeededResources: font Helvetica font Times-Roman 
%%EndComments
%%BeginProlog
%
%  PostScript prolog for output from xcircuit
%  Version: 2.4
%
%  Electrical circuit (and otherwise general) drawing program
%
%  Written by Tim Edwards 8/5/93--1/15/03  (tim@bach.ece.jhu.edu)
%  The Johns Hopkins University
%
%%BeginResource: procset XCIRCproc 2.4 2
% supporting definitions --- these are the primary xcircuit types.

/XCIRCsave save def
/topmat matrix currentmatrix def

/fontslant { /slant exch def [1 0 slant 1 0 0] 
    exch findfont exch makefont dup length dict /ndict exch def
    { 1 index /FID ne { ndict 3 1 roll put } { pop pop } ifelse } forall
    ndict definefont pop} def
/ul { dup type /stringtype eq showflag 1 eq and { gsave 
   currentpoint topmat setmatrix 0 0 moveto 2 index stringwidth pop (_)
   false charpath flattenpath pathbbox grestore exch pop 1 index
   sub setlinewidth exch pop currentpoint 3 -1 roll add moveto 0
   rlineto stroke moveto } if } def
/ol { dup type /stringtype eq showflag 1 eq and { gsave gsave
   currentpoint topmat setmatrix 2 index stringwidth pop 3 index
   true charpath flattenpath pathbbox grestore exch pop
   exch pop topmat setmatrix (_) true charpath pathbbox grestore
   exch pop 1 index sub setlinewidth exch pop currentpoint
   exch 4 1 roll exch sub add moveto pop 0 rlineto stroke
   moveto } if } def
/stW { gsave currentpoint newpath moveto true charpath flattenpath
	pathbbox pop exch pop sub grestore } def
/Ts {mark Tabs aload pop counttomark 1 add array astore /Tabs exch def Tabs
	0 currentpoint pop put} def
/Tbn {mark Tabs aload pop counttomark dup 2 add 1 roll cleartomark 1 sub} def
/Tb { 0 1 Tbn {Tabs exch get dup currentpoint pop lt
	{currentpoint exch pop moveto exit} {pop} ifelse } for } def
/Tf { Tbn -1 0 {Tabs exch get dup currentpoint pop gt
	{currentpoint exch pop moveto exit} {pop} ifelse } for } def
/qS { (aa) stW (a a) stW sub 4 div 0 Kn } def
/hS { qS qS } def
/pspc 0 def
/cf0 { scalefont setfont } bind def
/Kn { dup kY add /kY exch def rmoveto } bind def
/ss { /fscale fscale 0.67 mul def currentfont 0.67 cf0 0 fscale0 fscale mul
	0.33 mul neg Kn} def
/Ss { /fscale fscale 0.67 mul def currentfont 0.67 cf0 0 fscale0 fscale mul
	0.67 mul Kn } def
/ns { 0 kY neg Kn /kY 0 def /fscale 1.0 def xfont0 1.0 cf0 } def
/CR { ns 0 /Bline Bline fscale0 neg add def Bline moveto } def
/cf { dup type /realtype ne {1.0} if exch findfont exch kY 0 eq
	{ 40 mul dup /fscale0 exch def cf0 /xfont0 currentfont def}
	{fscale0 mul fscale mul cf0} ifelse } def
/ctmk { counttomark dup 2 add -1 roll pop } bind def
/label { gsave translate 0 0 moveto dup scale neg /rotval exch def
	/just exch def just 16 and 0 gt {gsave rotval rotate 0 1 dtransform
	gsave pagemat setmatrix idtransform exch grestore 1 0 dtransform
	gsave pagemat setmatrix idtransform exch grestore dup abs 1e-9 lt
	{pop mul 0 gt} {3 1 roll pop pop 0 lt} ifelse grestore {-1 /rotval
	rotval neg def /just just dup 3 and 1 ne {3 xor} if def} {1} ifelse
	exch -1e-9 lt {-1 /rotval rotval neg def /just just dup 12 and
	4 ne {12 xor} if def} {1} ifelse scale } if /showflag 0 def
	/fspc pspc def /Bline 0 def /Tabs 0 array def /fscale 1.0 def
	/kY 0 def gsave dup 1 add copy 0 exch 1 0 dtransform exch atan rotate
	{exch dup type /stringtype eq {true charpath flattenpath} {exec}
	ifelse } repeat pop pathbbox grestore 3 -1 roll pop 3 1 roll just
	1 and 0 gt {just 2 and 0 gt {exch pop neg fspc sub} {exch sub 0.5
	mul neg} ifelse} {pop neg fspc add} ifelse exch Bline exch just 4
	and 0 gt {just 8 and 0 gt {exch pop neg fspc sub} {add 0.5 mul neg}
	ifelse} {pop neg fspc add} ifelse rotval rotate Kn currentpoint
	translate /showflag 1 def /Bline 0 def /Tabs 0 array def /fscale
	1.0 def /kY 0 def {dup type /stringtype eq {show}{exec} ifelse}
	repeat grestore } def
/pinlabel { 4 index 32 and 0 ne hlevel 0 eq or { /pspc 10 def label
	/pspc 0 def } { pop pop pop pop pop {pop} repeat } ifelse } def
/pinglobal { pinlabel } def
/infolabel { pinlabel } def

/scb { setrgbcolor } bind def  /sce { defColor aload pop scb } bind def
/cRedef {/defColor currentcolor 3 array astore def} def
/begingate { /hlevel hlevel 1 add def /defColor currentcolor sce 3 array
	astore def gsave sce translate 0 0 moveto neg rotate dup abs scale
	} bind def
/makeparm  {3 string cvs dup length 1 add string /tstr exch def tstr exch
	1 exch putinterval tstr 0 (v) putinterval tstr cvn} bind def
/beginparm { -1 1 {makeparm exch def} for
	dup type /arraytype eq { aload length -1 1 {makeparm exch def}
	for } if begingate } bind def
/endgate { /hlevel hlevel 1 sub def grestore defColor aload pop cRedef
	scb} bind def

/hlevel 0 def
/tmpa [1 0 0 1 0 0] def
/gar {8 8 true tmpa {<c0 c0 00 00 0c 0c 00 00>} imagemask} bind
{8 8 true tmpa {<30 70 60 02 03 07 06 20>} imagemask} bind
{8 8 true tmpa {<0c 1e 1e 0c c0 e1 e1 c0>} imagemask} bind
{8 8 true tmpa {<0f 0f 0f 0f f0 f0 f0 f0>} imagemask} bind
{8 8 true tmpa {<3f f3 e1 e1 f3 3f 1e 1e>} imagemask} bind
{8 8 true tmpa {<df cf 8f 9f fd fc f8 f9>} imagemask} bind
{8 8 true tmpa {<ff 3f 3f ff ff f3 f3 ff>} imagemask} bind 7 array astore def
/ppaint { gsave clip tmpa dup setmatrix pathbbox neg exch neg 4 2 roll
  neg 4 -1 roll 2 copy gt {exch} if 8 div ceiling 8 mul 4 2 roll neg 2 copy
  gt {exch} if 8 div ceiling 8 mul 3 -1 roll -8 5 -1 roll
  { 3 index exch 5 exch put dup -8 3 index { 3 index
  exch 4 exch put 3 index exec } for } for pop pop pop pop grestore } bind def
/setstyles {
  currentlinewidth mul setlinewidth /style exch def
  style 1 and 0 gt not {closepath} if
  style 2 and 0 gt {currentlinewidth 4 mul dup 2 array astore 0 setdash} if
  style 4 and 0 gt {0.5 currentlinewidth 4 mul 2 array astore 0 setdash} if
  gsave style 16 and 0 gt { style 224 and -5 bitshift style 256 and 0 gt {
  7 exch sub 8 div dup 1 exch sub currentrgbcolor 3 array astore
  {3 copy mul add 4 1 roll pop} forall pop pop setrgbcolor eofill}
  {dup 7 lt {gar exch get ppaint} {pop eofill} ifelse} ifelse}
  {style 256 and 0 gt {1 setgray eofill} if} ifelse grestore style 8 and 0 gt 
  style 512 eq or {newpath} {stroke} ifelse grestore} def     

/polygon { gsave /num exch def moveto num 1 sub {lineto} repeat setstyles } def
/xcarc   { gsave newpath arc setstyles } def
/elb { matrix currentmatrix 7 -1 roll 7 -1 roll translate 5 1 roll 4 -1 roll
	3 index div 1 scale } def
/ele { 0 4 1 roll 0 4 1 roll } bind def
/ellipse { gsave elb newpath ele arc setmatrix setstyles } def
/pellip  { elb ele arc setmatrix } def
/nellip  { elb ele arcn setmatrix } def
/spline  { gsave moveto curveto setstyles } def
/polyc   { {lineto} repeat } bind def
/beginpath { gsave moveto } bind def
/endpath { setstyles } bind def
/bop	 { 1 setlinecap 0 setlinejoin 6 setmiterlimit 0 0 0 scb cRedef } def
/psinsertion {/PSobj save def /showpage {} def bop rotate translate dup scale} def
/end_insert {PSobj restore} def
/setpagemat {/pagemat matrix currentmatrix def} def
/inchscale  {setpagemat 0.375 mul dup scale} def
/cmscale    {setpagemat 0.35433071 mul dup scale} def

%%EndResource
%%EndProlog

% XCircuit output starts here.

%%Page: 1 1
%%PageOrientation: Portrait
/pgsave save def bop
% 234 334 offsets
% 32.00 8.00 gridspace
0.8182 inchscale
2.0000 setlinewidth

224 1.00 234 334 234 526 426 526 426 334 4 polygon
224 1.00 714 334 714 526 938 526 938 334 4 polygon
497 0.10 453 358 448 355 445 354 439 352 426 350 438 348 448 345 453 342 451 
346 451 350 451 353 453 358 12 polygon
1 1.00 234 462 426 462 2 polygon
1 1.00 234 398 426 398 2 polygon
1 1.00 298 526 298 334 2 polygon
1 1.00 362 526 362 334 2 polygon
1 1.00 714 510 426 510 2 polygon
497 0.10 687 478 692 475 695 474 701 472 714 470 702 468 692 465 687 462 689 
466 689 470 689 473 687 478 12 polygon
1 1.00 714 470 426 470 2 polygon
(1) {/Times-Roman cf} 2 16 0 1.00 258 478 label
(2) {/Helvetica cf} 2 16 0 1.00 322 478 label
(3) {/Times-Roman cf} 2 16 0 1.00 386 478 label
(4) {/Times-Roman cf} 2 16 0 1.00 258 414 label
(5) {/Helvetica cf} 2 16 0 1.00 322 414 label
(6) {/Times-Roman cf} 2 16 0 1.00 386 414 label
(8) {/Times-Roman cf} 2 16 0 1.00 322 350 label
(7) {/Helvetica cf} 2 16 0 1.00 258 350 label
(9) {/Times-Roman cf} 2 16 0 1.00 386 350 label
(Keypad) {/Helvetica 0.750 cf} {/Helvetica cf} 3 16 0 1.00 266 286 label
(Alarm) {/Helvetica 0.750 cf} {/Helvetica cf} 3 16 0 1.00 746 286 label
497 0.10 453 518 448 515 445 514 439 512 426 510 438 508 448 505 453 502 451 
506 451 510 451 513 453 518 12 polygon
497 0.10 453 414 448 411 445 410 439 408 426 406 438 404 448 401 453 398 451 
402 451 406 451 409 453 414 12 polygon
1 1.00 714 406 426 406 2 polygon
1 1.00 714 350 426 350 2 polygon
(Gnd) {/Times-Roman 0.750 cf} {/Times-Roman cf} 3 16 0 1.00 746 350 label
(Clock) {/Times-Roman 0.750 cf} {/Times-Roman cf} 3 16 0 1.00 746 398 label
(Serial data) {/Times-Roman 0.750 cf} {/Times-Roman cf} 3 16 0 1.00 746 454 
label
(+5V) {/Times-Roman 0.750 cf} {/Times-Roman cf} 3 16 0 1.00 746 494 label
(Alarm with remote keypad) {/Helvetica 0.750 cf} {/Helvetica cf} 3 16 0 1.00 
234 238 label
1 1.00 458 366 466 366 466 398 474 398 474 366 482 366 482 398 490 398 490 366 
9 polygon
1 1.00 490 366 498 366 498 398 506 398 506 366 514 366 514 398 522 398 522 366 
9 polygon
1 1.00 522 366 530 366 530 398 538 398 538 366 546 366 546 398 554 398 554 366 
9 polygon
1 1.00 554 366 562 366 562 398 570 398 570 366 578 366 578 398 586 398 586 366 
9 polygon
1 1.00 586 366 594 366 594 398 602 398 602 366 610 366 610 398 618 398 618 366 
9 polygon
1 1.00 618 366 626 366 626 398 634 398 634 366 642 366 642 398 650 398 650 366 
9 polygon
1 1.00 650 366 658 366 658 398 666 398 666 366 674 366 674 398 682 398 682 366 
9 polygon
1 1.00 682 366 690 366 2 polygon
1 1.00 458 430 482 430 482 462 498 462 498 430 514 430 514 462 546 462 546 430 
578 430 578 462 594 462 594 430 610 430 610 462 642 462 642 430 658 430 658 462 
674 462 674 430 690 430 22 polygon
pgsave restore showpage

%%Trailer
XCIRCsave restore
%%EOF
